<!DOCTYPE html>
<!--
  A quick-and-dirty HTML5 form for filling in Schedule 3 metadata and
  exporting to the RIF-CS compliant XML data form.

  Code author: Russell A. Edson, Biometry Hub
  Date last modified: 31/01/2022
-->
<html>
  <head>
    <title>Schedule 3 Metadata Form</title>
    <meta name="description" content="Form for filling out Sch.3 metadata.">
    <meta name="author" content="Biometry Hub">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">

    <style>
      div { padding-top: 8px; padding-bottom: 8px; }
      textarea { overflow-y: scroll; height: 100px; width: 100%; }
      #dataset_name { width: 100%; }
      #dataset_contracttitle { width: 100%; }
      #dataset_contractcode { width: 100%; }
      #dataset_location { width: 100%; }
      #dataset_subject { width: 100%; }
      #dataset_organisation { width: 100%; }
      #dataset_saginode { width: 100%; }
      #dataset_treatments { width: 100%; }
      #dataset_variables { width: 100%; }
      #dataset_design { width: 100%; }
      #dataset_files { width: 100%; }
      #dataset_rights { width: 100%; }
      #dataset_datefrom { width: 100%; }
      #dataset_dateto { width: 100%; }
      #dataset_datetext { width: 100%; }
      #xml_export_filename {width: 50%; }
    </style>
  </head>

  <body>
    <h1>Schedule 3 Metadata Form</h1>

    <!-- XML import functionality (for checking) -->
    <div>
      <p>
        (Optionally) upload an existing XML file to check:
      </p>

      <input type="file" id="xml_import">
    </div>

    <!-- Name of the dataset -->
    <div>
      <label for="dataset_name">Dataset Name:</label>

      <input type="text" id="dataset_name">
    </div>

    <!-- Project details -->
    <div>
      <h3>
        GRDC project details (i.e. the project that generated this dataset)
      </h3>

      <!-- GRDC contract title -->
      <div>
        <label for="dataset_contracttitle">GRDC contract title:</label>

        <input type="text" id="dataset_contracttitle">
      </div>

      <!-- GRDC project code -->
      <div>
        <label for="dataset_contractcode">GRDC contract code:</label>

        <input type="text" id="dataset_contractcode">
      </div>

      <!-- Location email address -->
      <div>
        <label for="dataset_location">Project point-of-contact email:</label>

        <input type="text" id="dataset_location">
      </div>

      <!-- Keywords -->
      <div>
        <label for="dataset_subject">Subject keywords:</label>

        <input type="text" id="dataset_subject">
      </div>

      <!-- Parties -->
      <div>
        <h4>Parties involved in the project</h4>

        <!-- Research organisation -->
        <div>
          <label for="dataset_organisation">
            (Primary) Research organisation:
          </label>

          <input type="text" id="dataset_organisation">
        </div>

        <!-- SAGI node -->
        <div>
          <label for="dataset_saginode">SAGI node:</label>

          <input type="text" id="dataset_saginode">
        </div>

        <!-- Additional parties -->
        <div>
          <p>
            Add details for as many organisational or individual parties
            as you like:
          </p>

          <div id="dataset_party"></div>

          <input type="button" id="add_party" value="Add new party">
        </div>
      </div>
    </div>

    <!-- Description -->
    <div>
      <h3>Dataset description (plain-text)</h3>

      <!-- General information -->
      <div>
        <label for="dataset_geninfo">
          General information about the dataset (where available):
        </label>

        <textarea id="dataset_geninfo"></textarea>
      </div>

      <!-- Treatment factors -->
      <div>
        <label for="dataset_treatments">
          Treatment factors (delimited by commas):
        </label>

        <input type="text" id="dataset_treatments">
      </div>

      <!-- Observed variables -->
      <div>
        <label for="dataset_variables">
          Observed variables (delimited by commas):
        </label>

        <input type="text" id="dataset_variables">
      </div>

      <div>
        <label for="dataset_design">
          Experimental design elements (delimited by commas):
        </label>

        <input type="text" id="dataset_design">
      </div>

      <div>
        <label for="dataset_files">
          Files associated with this dataset (delimited by commas):
        </label>

        <input type="text" id="dataset_files">
      </div>
    </div>

    <!-- Rights (auto-filled, shouldn't need to change) -->
    <div>
      <label for="dataset_rights">
        Dataset rights (modify if necessary):
      </label>

      <input type="text" id="dataset_rights"
        value="By agreement from GRDC and dataset co-owners">
    </div>

    <!-- Coverage -->
    <div>
      <h3>Dataset coverage (temporal/spatial)</h3>

      <!-- Temporal coverage -->
      <div>
        <p>Temporal coverage with dates in W3CDTF format (e.g. YYYY-MM-DD):</p>

        <!-- Start date (From...) -->
        <label for="dataset_datefrom">Start date: </label>

        <input type="text" id="dataset_datefrom">

        <!-- End date (To...) -->
        <label for="dataset_dateto">End date: </label>

        <input type="text" id="dataset_dateto">

        <!-- Otherwise, descriptive date instead -->
        <label for="dataset_datetext">
          (If unknown or overly vague, enter a text description here instead):
        </label>

        <input type="text" id="dataset_datetext">
      </div>

      <!-- Spatial coverage -->
      <div>
        <p>
          Spatial coverage (in KML lat/long coordinates or plaintext names).
          Add as many locations as needed:
        </p>

        <div id="dataset_spatial"></div>

        <input type="button" id="add_spatial" value="Add new location">
      </div>
    </div>

    <!-- Finally, click the button to export XML. -->
    <div>
      <p>
        Done. Export to RIF-CS standard XML:
      </p>

      <input type="text" id="xml_export_filename" value="output.xml">
      <input type="button" id="xml_export" value="Export to XML...">
    </div>
  </body>

  <script>
    /* For user-friendliness, disable the start/end date boxes if they
     * have provided a text description instead. If there is anything
     * in the text description box then entered dates are ignored during
     * the XML export.
     */
    var ignoreDates = false;
    document.getElementById("dataset_datetext").addEventListener(
      "input",
      function (evt) {
        const dateFrom = document.getElementById("dataset_datefrom");
        const dateTo = document.getElementById("dataset_dateto");
        const text = document.getElementById("dataset_datetext").value;

        if (text.length > 0) {
          ignoreDates = true;
          dateFrom.setAttribute("disabled", true);
          dateTo.setAttribute("disabled", true);
        } else {
          ignoreDates = false;
          dateFrom.removeAttribute("disabled");
          dateTo.removeAttribute("disabled");
        }
      }
    );

    /* Spatial location textboxes are auto-generated, and we keep track
     * of the ids for the XML export.
     */
    const spatialLocations = [ ];
    function addSpatialLocation() {
      const nextId = "dataset_spatial_" + (spatialLocations.length + 1);
      spatialLocations.push(nextId);

      const nextSpatial = document.createElement("input");
      nextSpatial.setAttribute("type", "text");
      nextSpatial.setAttribute("id", nextId);
      nextSpatial.setAttribute("style", "width: 100%");
      document.getElementById("dataset_spatial").appendChild(nextSpatial);
    }
    addSpatialLocation();
    document.getElementById("add_spatial").addEventListener(
      "click",
      addSpatialLocation
    );

    /* Parties are also auto-generated, and we keep track of the ids for
     * the XML export. Parties can be either organisational or
     * individual, and the user can freely swap between both.
     * (By default, a new Organisational-type party is created.)
     */
    const parties = [ ];
    function addParty() {
      const nextId = "dataset_party_" + (parties.length + 1);
      parties.push(nextId);

      const nextParty = document.createElement("span");
      nextParty.setAttribute("id", nextId);

      const partyType = document.createElement("div");

      const partyType1 = document.createElement("input");
      partyType1.setAttribute("type", "radio");
      partyType1.setAttribute("id", nextId + "_type_organisation");
      partyType1.setAttribute("name", nextId + "_type");
      partyType1.setAttribute("value", "Organisation");
      partyType1.checked = true;

      const partyType1Label = document.createElement("label");
      partyType1Label.setAttribute("for", nextId + "_type_organisation");
      partyType1Label.innerText = "Organisation";

      const partyType2 = document.createElement("input");
      partyType2.setAttribute("type", "radio");
      partyType2.setAttribute("id", nextId + "_type_individual");
      partyType2.setAttribute("name", nextId + "_type");
      partyType2.setAttribute("value", "Individual");

      const partyType2Label = document.createElement("label");
      partyType2Label.setAttribute("for", nextId + "_type_individual");
      partyType2Label.innerText = "Individual";

      partyType.appendChild(partyType1);
      partyType.appendChild(partyType1Label);
      partyType.appendChild(partyType2);
      partyType.appendChild(partyType2Label);

      const partyOrgTitle = document.createElement("input");
      partyOrgTitle.setAttribute("type", "text");
      partyOrgTitle.setAttribute("id", nextId + "_org_title");
      partyOrgTitle.setAttribute("style", "width: 100%");

      const partyOrgTitleLabel = document.createElement("label");
      partyOrgTitleLabel.setAttribute("for", nextId + "_org_title");
      partyOrgTitleLabel.setAttribute("id", nextId + "_org_title_label");
      partyOrgTitleLabel.innerText =
        "Title (e.g. 'Research Organisation', 'Project Partner'):";

      const partyOrgName = document.createElement("input");
      partyOrgName.setAttribute("type", "text");
      partyOrgName.setAttribute("id", nextId + "_org_name");
      partyOrgName.setAttribute("style", "width: 100%; margin-bottom: 20px");

      const partyOrgNameLabel = document.createElement("label");
      partyOrgNameLabel.setAttribute("for", nextId + "_org_name");
      partyOrgNameLabel.setAttribute("id", nextId + "_org_name_label");
      partyOrgNameLabel.innerText = "Name:";

      const partyIndTitle = document.createElement("input");
      partyIndTitle.setAttribute("type", "text");
      partyIndTitle.setAttribute("id", nextId + "_ind_title");
      partyIndTitle.setAttribute("style", "width: 100%; display: none");

      const partyIndTitleLabel = document.createElement("label");
      partyIndTitleLabel.setAttribute("for", nextId + "_ind_title");
      partyIndTitleLabel.setAttribute("id", nextId + "_ind_title_label");
      partyIndTitleLabel.setAttribute("style", "display: none");
      partyIndTitleLabel.innerText =
        "Title (e.g.'Research Contact', 'SAGI Contact'):";

      const partyIndName = document.createElement("input");
      partyIndName.setAttribute("type", "text");
      partyIndName.setAttribute("id", nextId + "_ind_name");
      partyIndName.setAttribute("style", "width: 100%; display: none");

      const partyIndNameLabel = document.createElement("label");
      partyIndNameLabel.setAttribute("for", nextId + "_ind_name");
      partyIndNameLabel.setAttribute("id", nextId + "_ind_name_label");
      partyIndNameLabel.setAttribute("style", "display: none");
      partyIndNameLabel.innerText = "Name:";

      const partyIndPosition = document.createElement("input");
      partyIndPosition.setAttribute("type", "text");
      partyIndPosition.setAttribute("id", nextId + "_ind_position");
      partyIndPosition.setAttribute("style", "width: 100%; display: none");

      const partyIndPositionLabel = document.createElement("label");
      partyIndPositionLabel.setAttribute("for", nextId + "_ind_position");
      partyIndPositionLabel.setAttribute("id", nextId + "_ind_position_label");
      partyIndPositionLabel.setAttribute("style", "display: none");
      partyIndPositionLabel.innerText = "Position:";

      const partyIndEmail = document.createElement("input");
      partyIndEmail.setAttribute("type", "text");
      partyIndEmail.setAttribute("id", nextId + "_ind_email");
      partyIndEmail.setAttribute(
        "style",
        "width: 100%; margin-bottom: 20px; display: none"
      );

      const partyIndEmailLabel = document.createElement("label");
      partyIndEmailLabel.setAttribute("for", nextId + "_ind_email");
      partyIndEmailLabel.setAttribute("id", nextId + "_ind_email_label");
      partyIndEmailLabel.setAttribute("style", "display: none");
      partyIndEmailLabel.innerText = "Contact email:";

      nextParty.appendChild(partyType);
      nextParty.appendChild(partyOrgTitleLabel)
      nextParty.appendChild(partyOrgTitle);
      nextParty.appendChild(partyOrgNameLabel);
      nextParty.appendChild(partyOrgName);
      nextParty.appendChild(partyIndTitleLabel);
      nextParty.appendChild(partyIndTitle);
      nextParty.appendChild(partyIndNameLabel);
      nextParty.appendChild(partyIndName);
      nextParty.appendChild(partyIndPositionLabel);
      nextParty.appendChild(partyIndPosition);
      nextParty.appendChild(partyIndEmailLabel);
      nextParty.appendChild(partyIndEmail);

      /* Add an event listener for the radio buttons that lets us toggle
       * between Organisation and Individual-type parties.
       */
      partyType1.addEventListener(
        "change",
        function () { toggleParty(nextId, true) }
      );
      partyType2.addEventListener(
        "change",
        function () { toggleParty(nextId, false) }
      );
      document.getElementById("dataset_party").appendChild(nextParty);
    }

    addParty();
    document.getElementById("add_party").addEventListener("click", addParty);

    /* Toggle the party as an organisation or individual. */
    function toggleParty(partyId, organisation) {
      var orgDisplay = "";
      var indDisplay = "none";
      if (!organisation) {
        orgDisplay = "none";
        indDisplay = "";
      }

      document.getElementById(partyId + "_org_title")
        .style.display = orgDisplay;
      document.getElementById(partyId + "_org_title_label")
        .style.display = orgDisplay;
      document.getElementById(partyId + "_org_name")
        .style.display = orgDisplay;
      document.getElementById(partyId + "_org_name_label")
        .style.display = orgDisplay;
      document.getElementById(partyId + "_ind_title")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_title_label")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_name")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_name_label")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_position")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_position_label")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_email")
        .style.display = indDisplay;
      document.getElementById(partyId + "_ind_email_label")
        .style.display = indDisplay;
    }

    /* For both the import and export, we set/check that the
     * registryObject group and originatingSource are "Grains
     * Research and Development Corporation - Statistics for the
     * Australian Grains Industry 3"
     */
    const grdcSagi = "Grains Research and Development Corporation" +
      " - Statistics for the Australian Grains Industry 3";

    /* Helper function: trim whitespace from a given string. */
    function trimws(string) {
      return string.replace(/[\n|\t| ]+/g, " ").replace(/^\s+|\s+$/gm, "");
    }

    /* An XML file can be uploaded to populate the fields in the form
     * (and serve as a double-check that everything appears properly).
     */
    function xmlImport(evt) {
      /* Load the XML file selected by the user. */
      var file = evt.target.files[0];

      var reader = new FileReader();
      reader.onload = (function (reader) {
        return function () { xmlParse(reader.result); }
      })(reader);
      reader.readAsText(file);
    }

    /* Parse the XML, double-checking that everything exists according
     * to GRDC guidelines. We explicitly step through the XML
     * structure: monitor the console for any errors, which will mean
     * that the XML structure does not match expectations.
     *
     * We also populate the HTML form fields as we go.
     */
    function xmlParse(xmlString) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlString, "text/xml");
      var traverse = xml;

      traverse = traverse.getElementsByTagName("registryObjects")[0];
      traverse = traverse.getElementsByTagName("registryObject")[0];

      /* registryObject group and originatingSource should be "Grains
       * Research and Development Corporation - Statistics for the
       * Australian Grains Industry 3".
       */
      const registryObjectGroup = traverse.attributes["group"].textContent;
      traverse = traverse.getElementsByTagName("originatingSource")[0];
      const originatingSource = traverse.childNodes[0].nodeValue;
      traverse = traverse.parentNode;
      if (registryObjectGroup != grdcSagi && originatingSource != grdcSagi) {
        console.error("registryObject group or originatingSource incorrect.");
      }

      /* The collection type should be "dataset". */
      traverse = traverse.getElementsByTagName("collection")[0];
      if (traverse.attributes["type"].textContent != "dataset") {
        console.error("collection type=... mismatch (should be 'dataset').");
      }

      /* Get the name of the dataset. */
      traverse = traverse.getElementsByTagName("name")[0];
      if (traverse.attributes["type"].textContent != "primary") {
        console.error("name type=... mismatch (should be 'primary').");
      }
      traverse = traverse.getElementsByTagName("namePart")[0];
      const datasetName = traverse.childNodes[0].textContent;
      document.getElementById("dataset_name").value = datasetName;
      traverse = traverse.parentNode.parentNode;

      /* Get the location of the dataset. */
      traverse = traverse.getElementsByTagName("location")[0];
      traverse = traverse.getElementsByTagName("address")[0];
      traverse = traverse.getElementsByTagName("electronic")[0];
      if (traverse.attributes["type"].textContent != "email") {
        console.error("electronic type=... mismatch (should be 'email').");
      }
      traverse = traverse.getElementsByTagName("value")[0];
      const datasetLocation = traverse.childNodes[0].textContent;
      document.getElementById("dataset_location").value = datasetLocation;
      traverse = traverse.parentNode.parentNode.parentNode.parentNode;

      /* Get and parse the description of the dataset. (Assume that
       * everything is in the order: general description, treatments,
       * variables, design elements, filenames.)
       */
      traverse = traverse.getElementsByTagName("description")[0];
      if (traverse.attributes["type"].textContent != "full") {
        console.error("description type=... mismatch (should be 'full').");
      }
      const description = traverse.getElementsByTagName("p");
      const datasetGeninfo = trimws(description[0].childNodes[0].textContent);
      document.getElementById("dataset_geninfo").value = datasetGeninfo;
      const datasetTreatments =
        trimws(description[1].childNodes[0].textContent)
        .match(/(?<=: ).*/g)[0]
        .replace(/,[ ]*/g, ",");
      document.getElementById("dataset_treatments").value = datasetTreatments;
      const datasetVariables =
        trimws(description[2].childNodes[0].textContent)
        .match(/(?<=: ).*/g)[0]
        .replace(/,[ ]*/g, ",");
      document.getElementById("dataset_variables").value = datasetVariables;
      const datasetDesign =
        trimws(description[3].childNodes[0].textContent)
        .match(/(?<=: ).*/g)[0]
        .replace(/,[ ]*/g, ",");
      document.getElementById("dataset_design").value = datasetDesign;
      const datasetFiles =
        trimws(description[4].childNodes[0].textContent)
        .match(/(?<=: ).*/g)[0]
        .replace(/,[ ]*/g, ",");
        document.getElementById("dataset_files").value = datasetFiles;
      traverse = traverse.parentNode;

      /* Get the access rights for the dataset. */
      traverse = traverse.getElementsByTagName("rights")[0];
      if (traverse.attributes["type"].textContent != "accessRights") {
        console.error("rights type=... mismatch (should be 'accessRights').");
      }
      traverse = traverse.getElementsByTagName("p")[0];
      const datasetRights = traverse.childNodes[0].textContent;
      document.getElementById("dataset_rights").value = datasetRights;
      traverse = traverse.parentNode.parentNode;

      /* Get the temporal coverage for the dataset. Here we check to
       * see whether dateFrom and dateTo exist: if they don't assume
       * that a (vague) description exists instead.
       */
      traverse = traverse.getElementsByTagName("coverage")[0];
      traverse = traverse.getElementsByTagName("temporal")[0];

      if (traverse.getElementsByTagName("date").length > 0) {
        const dateFrom = traverse.querySelector("date[type='dateFrom']");
        if (dateFrom.attributes["dateFormat"].value != "W3CDTF") {
          console.error("dateFrom format=... mismatch (should be 'W3CDTF').");
        }
        const datasetDateFrom = dateFrom.textContent;
        document.getElementById("dataset_datefrom").value = datasetDateFrom;

        const dateTo = traverse.querySelector("date[type='dateTo']");
        if (dateTo.attributes["dateFormat"].value != "W3CDTF") {
          console.error("dateTo format=... mismatch (should be 'W3CDTF').");
        }
        const datasetDateTo = dateTo.textContent;
        document.getElementById("dataset_dateto").value = datasetDateTo;
      } else {
        /* Assume a description instead. */
        const datasetDateText = traverse.childNodes[0].textContent;
        document.getElementById("dataset_datetext").value = datasetDateText;
        ignoreDates = true;
        document.getElementById("dataset_datefrom")
          .setAttribute("disabled", true);
        document.getElementById("dataset_dateto")
          .setAttribute("disabled", true);
      }
      traverse = traverse.parentNode;

      /* Get the spatial coverage for the dataset (generate as many
       * rows as necessary.)
       */
      const spatial = traverse.getElementsByTagName("spatial");
      for (i = 0; i < spatial.length; i++) {
        if (i >= spatialLocations.length) {
          addSpatialLocation();
        }
        var datasetSpatial = spatial[i].textContent;
        document.getElementById(spatialLocations[i]).value = datasetSpatial;
      }
      traverse = traverse.parentNode;

      /* Get the subject keywords for the dataset. */
      //TODO: Are these comma-separated? At the moment we just treat it
      //      as a text string, but this might need to be changed later.
      traverse = traverse.getElementsByTagName("subject")[0];
      if (traverse.attributes["type"].textContent != "local") {
        console.error("subject type=... mismatch (should be 'local').");
      }
      const datasetSubject = traverse.childNodes[0].textContent;
      document.getElementById("dataset_subject").value = datasetSubject;
      traverse = traverse.parentNode;

      /* Get the contract title and contract code (in the 'activity'
       * relatedInfo tag), and confirm the XML structure.
       */
      traverse = traverse.querySelector("relatedInfo[type='activity']");
      traverse = traverse.getElementsByTagName("title")[0];
      const datasetContractCode = traverse.childNodes[0].textContent;
      document.getElementById("dataset_contractcode").value =
        datasetContractCode;
      traverse = traverse.parentNode;
      traverse = traverse.getElementsByTagName("notes")[0];
      const datasetContractTitle = traverse.childNodes[0].textContent;
      document.getElementById("dataset_contracttitle").value =
        datasetContractTitle;
      traverse = traverse.parentNode;
      traverse = traverse.getElementsByTagName("identifier")[0];
      if (traverse.attributes["type"].textContent != "local") {
        console.error("identifier type=... mismatch (should be 'local').");
      }
      if (traverse.childNodes[0].textContent != datasetContractCode) {
        console.error("identifier != title in relatedInfo['activity'].");
      }
      traverse = traverse.parentNode.parentNode;

      /* Get the listed parties (including the primary Research
       * Organisation and SAGI Node, which we handle specifically).
       * Here we assume that the priamry research organisation is the
       * first listed party that explicitly has 'Research Organisation'
       * as its title, and the SAGI node is the first party that has
       * 'SAGI Node' in its title, both case-sensitive. The other
       * parties are toggled as organisations or individuals depending
       * on how the XML looks: if the identifier text matches the notes
       * text, we assume an organisation, otherwise assume a party.
       */
      const partyElements =
        traverse.querySelectorAll("relatedInfo[type='party']");

      /* Research Organisation */
      var i = 0;
      while (i < partyElements.length &&
        partyElements[i].getElementsByTagName("title")[0].textContent !=
        "Research Organisation") {
          i++;
      }
      if (i == partyElements.length) {
        console.error("No 'Research Organisation' party found.");
      } else {
        traverse = partyElements[i];
        const organisation =
          traverse.getElementsByTagName("notes")[0].textContent;
        document.getElementById("dataset_organisation").value = organisation;
        traverse = traverse.getElementsByTagName("identifier")[0];
        if (traverse.attributes["type"].textContent != "local") {
          console.error("identifier type=... mismatch (should be 'local').");
        }
        if (traverse.childNodes[0].textContent != organisation) {
          console.error("identifier != notes in Research Organisation party.");
        }
        traverse = traverse.parentNode.parentNode;
      }

      /* SAGI Node */
      var j = 0;
      while (j < partyElements.length &&
        partyElements[j].getElementsByTagName("title")[0].textContent !=
        "SAGI Node") {
          j++;
      }
      if (j == partyElements.length) {
        console.error("No 'SAGI Node' party found.");
      } else {
        traverse = partyElements[j];
        const sagiNode = traverse.getElementsByTagName("notes")[0].textContent;
        document.getElementById("dataset_saginode").value = sagiNode;
        traverse = traverse.getElementsByTagName("identifier")[0];
        if (traverse.attributes["type"].textContent != "local") {
          console.error("identifier type=... mismatch (should be 'local').");
        }
        if (traverse.childNodes[0].textContent != sagiNode) {
          console.error("identifier != notes in SAGI Node party.");
        }
        traverse = traverse.parentNode.parentNode;
      }

      /* Other parties are populated as either organisations or
       * individuals depending on whether their identifier text matches
       * with the notes text.
       */
      for (k = 0, count = 0; k < partyElements.length; k++) {
        if (k != i && k != j) {
          if (count >= parties.length) {
            addParty();
          }
          traverse = partyElements[k];

          traverse = traverse.getElementsByTagName("title")[0];
          var partyTitle = trimws(traverse.childNodes[0].textContent);
          traverse = traverse.parentNode;
          traverse = traverse.getElementsByTagName("notes")[0];
          var partyNotes = trimws(traverse.childNodes[0].textContent);
          traverse = traverse.parentNode;
          traverse = traverse.getElementsByTagName("identifier")[0];
          if (traverse.attributes["type"].textContent != "local") {
            console.error("identifier type=... mismatch (should be 'local').");
          }
          var partyIdentifier = trimws(traverse.childNodes[0].textContent);
          traverse = traverse.parentNode;

          if (partyNotes == partyIdentifier) {
            /* Assume an organisation in this case. */
            document.getElementById(parties[count] + "_type_organisation")
              .checked = true;
            toggleParty(parties[count], true);

            document.getElementById(parties[count] + "_org_title").value =
              partyTitle;
            var partyName = trimws(partyNotes);
            document.getElementById(parties[count] + "_org_name").value =
              partyName;
          } else {
            /* Assume an individual in this case. */
            document.getElementById(parties[count] + "_type_individual")
              .checked = true;
            toggleParty(parties[count], false);

            document.getElementById(parties[count] + "_ind_title").value =
              partyTitle;
            partyNotes = partyNotes.split(",");
            var partyName = trimws(partyNotes[0]);
            document.getElementById(parties[count] + "_ind_name").value =
              partyName;
            var partyPosition = trimws(partyNotes[1]);
            document.getElementById(parties[count] + "_ind_position").value =
              partyPosition;
            var partyEmail = trimws(partyIdentifier);
            document.getElementById(parties[count] + "_ind_email").value =
              partyEmail;
          }

          count++;
        }
      }

      /* By default, the export filename is the input filename (so that
       * changes can be overwritten, which is presumably the typical
       * use-case).
       */
      var cleaned = datasetName.match(/\w+/g);
      if (cleaned == null) {
        cleaned = [ "output" ];
      }
      const filename = cleaned.join("_") + ".xml";

      document.getElementById("xml_export_filename").value = filename;
    }
    document.getElementById("xml_import").addEventListener(
      "change",
      xmlImport,
      false
    );

    /* Finally, the fields are all exported to RIF-CS compliant XML. */
    function xmlExport(evt) {
      const filename = document.getElementById("xml_export_filename").value;

      /* Create the XML string and populate the fields as we go,
       * extracting the relevant bits from the HTML form fields.
       */
      var xmlString = "<registryObjects></registryObjects>";
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlString, "text/xml");
      var traverse = xml.getElementsByTagName("registryObjects")[0];

      /* The registryObject has group="Grains Research and Development
       * Corporation - Statistics for the Australian Grains Industry 3".
       */
      var registryObject = xml.createElement("registryObject");
      registryObject.setAttribute("group", grdcSagi);
      traverse.appendChild(registryObject);
      traverse = registryObject;

      /* The originatingSource has type="" and text content
       * "Grains Research and Development Corporation - Statistics for
       * the Australian Grains Industry 3".
       */
      var originatingSource = xml.createElement("originatingSource");
      originatingSource.setAttribute("type", "");
      originatingSource.textContent = grdcSagi;
      traverse.appendChild(originatingSource);

      /* The collection has type="dataset" and contains all of the
       * dataset metadata.
       */
      var collection = xml.createElement("collection");
      collection.setAttribute("type", "dataset");
      traverse.appendChild(collection);
      traverse = collection;

      /* The name has type="primary" and contains a sub-element namePart
       * that holds the text name for the dataset.
       */
      const datasetName = trimws(document.getElementById("dataset_name").value);
      var name_ = xml.createElement("name");
      name_.setAttribute("type", "primary");
      traverse.appendChild(name_);
      traverse = name_;
      var namePart = xml.createElement("namePart");
      namePart.textContent = datasetName;
      traverse.appendChild(namePart);
      traverse = traverse.parentNode;

      /* The location holds an address tag, which in turn holds an
       * electronic tag with type="email", which in turn holds a value
       * tag with the text of the point of contact email.
       */
      const datasetLocation =
        trimws(document.getElementById("dataset_location").value);
      var location_ = xml.createElement("location");
      traverse.appendChild(location_);
      traverse = location_;
      var address_ = xml.createElement("address");
      traverse.appendChild(address_);
      traverse = address_;
      var electronic = xml.createElement("electronic");
      electronic.setAttribute("type", "email");
      traverse.appendChild(electronic);
      traverse = electronic;
      var value_ = xml.createElement("value");
      value_.textContent = datasetLocation;
      traverse.appendChild(value_);
      traverse = traverse.parentNode.parentNode.parentNode;

      /* The description has type="full" and contains separate p
       * paragraphs for the general info, treatment factors,
       * observed variables, experimental design elements and filenames
       * in that order.
       */
      const datasetGenInfo =
        trimws(document.getElementById("dataset_geninfo").value);
      const datasetTreatments =
        trimws(document.getElementById("dataset_treatments").value);
      const datasetVariables =
        trimws(document.getElementById("dataset_variables").value);
      const datasetDesign =
        trimws(document.getElementById("dataset_design").value);
      const datasetFiles =
        trimws(document.getElementById("dataset_files").value);
      var description = xml.createElement("description");
      description.setAttribute("type", "full");
      traverse.appendChild(description);
      traverse = description;
      var p_ = xml.createElement("p");
      p_.textContent = datasetGenInfo;
      traverse.appendChild(p_);
      var p_ = xml.createElement("p");
      p_.textContent = "Treatment factors: " +
        datasetTreatments.replaceAll(",", ", ");
      traverse.appendChild(p_);
      var p_ = xml.createElement("p");
      p_.textContent = "Variables: " +
        datasetVariables.replaceAll(",", ", ");
      traverse.appendChild(p_);
      var p_ = xml.createElement("p");
      p_.textContent = "Experimental design elements: " +
        datasetDesign.replaceAll(",", ", ");
      traverse.appendChild(p_);
      var p_ = xml.createElement("p");
      p_.textContent = "Filenames: " + datasetFiles.replaceAll(",", ", ");
      traverse.appendChild(p_);
      traverse = traverse.parentNode;

      /* The rights tag has type="accessRights" and contains a p tag
       * that holds the access rights text.
       */
      const datasetRights =
        trimws(document.getElementById("dataset_rights").value);
      var rights = xml.createElement("rights");
      rights.setAttribute("type", "accessRights");
      traverse.appendChild(rights);
      traverse = rights;
      var p_ = xml.createElement("p");
      p_.textContent = datasetRights;
      traverse.appendChild(p_);
      traverse = traverse.parentNode;

      /* The coverage tag contains both temporal and spatial tags. */
      var coverage = xml.createElement("coverage");
      traverse.appendChild(coverage);
      traverse = coverage;

      /* The temporal tag will either:
       *   1/ have type="text" and contain the textual description of
       *      the tempoarl coverage, if only a vague description was
       *      given in the HTML form, or:
       *   2/ have no type or other attributes, but contain date tags
       *      with type="dateFrom" and "dateTo", and
       *      dateFormat="W3CDTF", which contain the dates as text.
       */
      const datasetDateFrom =
        trimws(document.getElementById("dataset_datefrom").value);
      const datasetDateTo =
        trimws(document.getElementById("dataset_dateto").value);
      const datasetDateText =
        trimws(document.getElementById("dataset_datetext").value);
      var temporal = xml.createElement("temporal");
      if (ignoreDates) {
        temporal.setAttribute("type", "text");
        temporal.textContent = datasetDateText;
      } else {
        var dateFrom = xml.createElement("date");
        dateFrom.setAttribute("type", "dateFrom");
        dateFrom.setAttribute("dateFormat", "W3CDTF");
        dateFrom.textContent = datasetDateFrom;
        temporal.appendChild(dateFrom);
        var dateTo = xml.createElement("date");
        dateTo.setAttribute("type", "dateTo");
        dateTo.setAttribute("dateFormat", "W3CDTF");
        dateTo.textContent = datasetDateTo;
        temporal.appendChild(dateTo);
      }
      traverse.appendChild(temporal);

      /* There will be multiple spatial tags for each spatial location
       * specified in the form, and they each have type="text" and
       * contain the text for the locations (which may or may not be
       * GPS coordinates).
       */
      for (i = 0; i < spatialLocations.length; i++) {
        var spatialLocation =
          trimws(document.getElementById(spatialLocations[i]).value);
        if (spatialLocation.length > 0) {
          var spatial = xml.createElement("spatial");
          spatial.setAttribute("type", "text");
          spatial.textContent = spatialLocation;
          traverse.appendChild(spatial);
        }
      }
      traverse = traverse.parentNode;

      /* The subject has type="local" and contains the subject keywords
       * for the project.
       */
      const datasetSubject =
        trimws(document.getElementById("dataset_subject").value);
      var subject = xml.createElement("subject");
      subject.setAttribute("type", "local");
      subject.textContent = datasetSubject;
      traverse.appendChild(subject);

      /* The first relatedInfo tag has type="activity" and contains
       * a title tag which has the text for the GRDC contract code,
       * a notes tag that has the GRDC contract title text, and an
       * identifier tag with type="local" that also contains the
       * GRDC contract code.
       */
      const datasetContractTitle =
        trimws(document.getElementById("dataset_contracttitle").value);
      const datasetContractCode =
        trimws(document.getElementById("dataset_contractcode").value);
      var relatedInfo = xml.createElement("relatedInfo");
      relatedInfo.setAttribute("type", "activity");
      traverse.appendChild(relatedInfo);
      traverse = relatedInfo;
      var title_ = xml.createElement("title");
      title_.textContent = datasetContractCode;
      traverse.appendChild(title_);
      var notes_ = xml.createElement("notes");
      notes_.textContent = datasetContractTitle;
      traverse.appendChild(notes_);
      var identifier_ = xml.createElement("identifier");
      identifier_.setAttribute("type", "local");
      identifier_.textContent = datasetContractCode;
      traverse.appendChild(identifier_);
      traverse = traverse.parentNode;

      /* By convention, the second relatedInfo tag has type="party"
       * with a title tag containing "Research Organisation", a notes
       * tag containing the research organisation, and an identifier
       * tag with type="local" that also contains the research
       * organisation text (for this primary organisation).
       */
      const datasetOrganisation =
        trimws(document.getElementById("dataset_organisation").value);
      var relatedInfo = xml.createElement("relatedInfo");
      relatedInfo.setAttribute("type", "party");
      traverse.appendChild(relatedInfo);
      traverse = relatedInfo;
      var title_ = xml.createElement("title");
      title_.textContent = "Research Organisation";
      traverse.appendChild(title_);
      var notes_ = xml.createElement("notes");
      notes_.textContent = datasetOrganisation;
      traverse.appendChild(notes_);
      var identifier_ = xml.createElement("identifier");
      identifier_.setAttribute("type", "local");
      identifier_.textContent = datasetOrganisation;
      traverse.appendChild(identifier_);
      traverse = traverse.parentNode;

      /* By convention, the third relatedInfo tag has type="party",
       * with a title tag containing "SAGI Node", a notes tag containing
       * containing the SAGI node that worked on the project, and an
       * identifier tag with type="local" that also contains the
       * SAGI node text.
       */
      const datasetSagiNode =
        trimws(document.getElementById("dataset_saginode").value);
      var relatedInfo = xml.createElement("relatedInfo");
      relatedInfo.setAttribute("type", "party");
      traverse.appendChild(relatedInfo);
      traverse = relatedInfo;
      var title_ = xml.createElement("title");
      title_.textContent = "SAGI Node";
      traverse.appendChild(title_);
      var notes_ = xml.createElement("notes");
      notes_.textContent = datasetSagiNode;
      traverse.appendChild(notes_);
      var identifier_ = xml.createElement("identifier");
      identifier_.setAttribute("type", "local");
      identifier_.textContent = datasetSagiNode;
      traverse.appendChild(identifier_);
      traverse = traverse.parentNode;

      /* The rest of the related Info tags are the parties, in the
       * same order as they appear in the HTML form. Each party will
       * have a title tag, a notes tag, and an identifier tag with
       * type="local". For organisation parties, the notes tag text
       * matches exactly with the identifier text. For individual
       * parties, the notes tag text is the concatenation of the party
       * name and their position (comma-separated), and the identifier
       * text is the given contact email. (Parties with no active text
       * fields are ignored.)
       */
      for (i = 0; i < parties.length; i++) {
        var organisation = document
          .getElementById(parties[i] + "_type_organisation").checked;
        if (organisation) {
          var datasetOrgTitle = trimws(
            document.getElementById(parties[i] + "_org_title").value
          );
          var datasetOrgName = trimws(
            document.getElementById(parties[i] + "_org_name").value
          );
          if (datasetOrgTitle.length > 0 || datasetOrgName.length > 0) {
            var relatedInfo = xml.createElement("relatedInfo");
            relatedInfo.setAttribute("type", "party");
            traverse.appendChild(relatedInfo);
            traverse = relatedInfo;
            var title_ = xml.createElement("title");
            title_.textContent = datasetOrgTitle;
            traverse.appendChild(title_);
            var notes_ = xml.createElement("notes");
            notes_.textContent = datasetOrgName;
            traverse.appendChild(notes_);
            var identifier_ = xml.createElement("identifier");
            identifier_.setAttribute("type", "local");
            identifier_.textContent = datasetOrgName;
            traverse.appendChild(identifier_);
            traverse = traverse.parentNode;
          }
        } else {
          var datasetIndTitle = trimws(
            document.getElementById(parties[i] + "_ind_title").value
          );
          var datasetIndName = trimws(
            document.getElementById(parties[i] + "_ind_name").value
          );
          var datasetIndPosition = trimws(
            document.getElementById(parties[i] + "_ind_position").value
          );
          var datasetIndEmail = trimws(
            document.getElementById(parties[i] + "_ind_email").value
          );
          if (datasetIndTitle.length > 0 || datasetIndName.length > 0 ||
            datasetIndPosition.length > 0 || datasetIndEmail.length > 0) {
                var relatedInfo = xml.createElement("relatedInfo");
                relatedInfo.setAttribute("type", "party");
                traverse.appendChild(relatedInfo);
                traverse = relatedInfo;
                var title_ = xml.createElement("title");
                title_.textContent = datasetIndTitle;
                traverse.appendChild(title_);
                var notes_ = xml.createElement("notes");
                notes_.textContent =
                  [datasetIndName, datasetIndPosition].join(", ");
                traverse.appendChild(notes_);
                var identifier_ = xml.createElement("identifier");
                identifier_.setAttribute("type", "local");
                identifier_.textContent = datasetIndEmail;
                traverse.appendChild(identifier_);
                traverse = traverse.parentNode;
              }
        }
      }

      /* Finally, serialize the XML to a string for the download. */
      const serializer = new XMLSerializer();
      xmlString = serializer.serializeToString(xml);

      /* Pretty-print the XML so that everything is nicely tabbed
       * and newline'd.
       */
      var pretty = "";
      var tagStack = [ ];
      var tags = xmlString.split(/(?<=>)\s*(?=<)/);
      for (i = 0; i < tags.length; i++) {
        var tagType = tags[i].match(/\w+/)[0];
        var selfClosing = (tags[i].search("<" + tagType) >= 0) &&
          ((tags[i].search("</" + tagType + ">") >= 0) ||
          (tags[i].slice(-2) == "/>"));
        var closing = (tags[i].search("</" + tagType + ">") >= 0);

        if (!selfClosing) {
          if (!(tagStack.length > 0) || (tagStack.slice(-1)[0] != tagType) ||
            !closing) {
              tagStack.push(tagType);
          }
        } else {
          tagStack.push(tagType);
        }

        /* Indent */
        for (j = 0; j < tagStack.length - 1; j++) { pretty += "\t"; }
        pretty += tags[i] + "\n";

        if (closing || selfClosing) {
          tagStack.pop();
        }
      }

      var downloadElement = document.createElement("a");
      downloadElement.setAttribute(
        "href",
        "data:text/plain;charset=utf-8," + encodeURIComponent(pretty)
      );
      downloadElement.setAttribute("download", filename);
      downloadElement.click();
    }
    document.getElementById("xml_export").addEventListener("click", xmlExport);

    /* For convenience, the XML filename for the export defaults to
     * whatever is entered for the dataset name (sans any
     * special characters).
     */
    document.getElementById("dataset_name").addEventListener(
      "input",
      function (evt) {
        const datasetName = document.getElementById("dataset_name").value;

        var cleaned = datasetName.match(/\w+/g);
        if (cleaned == null) {
          cleaned = [ "output" ];
        }
        const filename = cleaned.join("_") + ".xml";

        document.getElementById("xml_export_filename").value = filename;
      }
    );
  </script>
</html>
